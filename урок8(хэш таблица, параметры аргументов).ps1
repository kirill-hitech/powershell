##### пример работы сплаттинг оператора при работе с хеш таблицами:
# Splatting is a method of passing a collection of parameter values to a command as a unit.
# Splatting это метод передачи коллекции параметров значений в команду в виде единого целого.
# Сплаттинг оператор выглядит как стандартная переменная, но начинаются с символа ( @ )
# хеш таблица - разновидность массива, где нет индексов,
# а вместо них используются строковые значения, которые мы сами можем задавать

# пример объявления хеш таблицы
$HashArguments = @{
  Path = "test.txt"
  Destination = "test2.txt"
  WhatIf = $true
}

# пример вызова значения из хештаблицы по индексу
$HashArguments["Destination"]  # test2.txt

Copy-Item @HashArguments   # будет то же что и
Copy-Item -Path "test.txt" -Destination "test2.txt" -WhatIf $true


# пример добавления ключа в конец хеш таблицы и значения
# просто используем метод Add с двумя аргументами
$HashArguments.Add("testname","testvalue")

### пример работы сплаттинг оператора с масивом :

$ArrayArguments = "test.txt", "test2.txt"
Copy-Item @ArrayArguments -WhatIf

# пример сплаттинг оператора для быстрой работы с аргументами в функциях:
function Get-MyProcess { Get-Process @Args }
Get-MyProcess wlanext, WUDFHost

#### когда мы объявляем перменнную не делая ее определение,
# то cчитается, что такая переменная ссылатеся на значение типа $null

$temp
<#
имя_переменной       значение
_________________|_________
$temp            |     $null        # вот так это выглядит до определения переменной

#>
# поэтому
$temp -eq $null  # = true

$temp = 123

<#

имя_переменной       значение
_________________|_________
$temp            |     123        # вот так это выглядит после определения переменной

#>
# поэтому
$temp -eq $null  # = false


#####
# $PSBoundParameters - автоматическая переменная типа PSBoundParametersDictionary (похожа на хештаблицу), содержит в себе аргументы и значения.
# может использоваться в функциях или скриптах, где на вход подаются аргументы.


# Объектно-ориентированное программирование
# https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5

##### пример обработки исключений в powershell с помощью блоков try,catch,finally

function money{
[Char]$a=163 # символ фунта 
$text = "Введите ĸоличество " # общий текст
[Bool]$exitflag = 0
do{
    try # спец блок куда помещается код, в котором может возникнуть исключение
    {
        [int32]$funt=Read-Host ($text+"фунтов") - # читаем фунты из консоли
        $exitflag = $true # если выше строкой возникло исключение, то эта строка выполнена не будет - будет переход ранее выполнен в блок catch
    }
    catch # блок кетч для этого класса исключений InvalidCastFromStringToInteger
    {
        # внутри блока кетч нужно описать что делать, если возникла такая ошибка?
            write-host "значение должно быть числовым"
            $exitflag = $false
    }
}until($exitflag)

do{
    try # спец блок куда помещается код, в котором может возникнуть исключение
    {
        [int32]$shilling=Read-Host ($text+"шиллингов") # читаем шиллинги из консоли
        $exitflag = $true # если выше строкой возникло исключение, то эта строка выполнена  не будет - будет переход ранее выполнен в блок catch
    }
    catch # блок кетч для этого класса исключений InvalidCastFromStringToInteger
    {
        # внутри блока кетч нужно описать что делать, если возникла такая ошибка?
            write-host "значение должно быть числовым"
            $exitflag = $false
    }
}until($exitflag)


do{
    try # спец блок куда помещается код, в котором может возникнуть исключение
    {
        [int32]$pens=Read-Host ($text+"пенсов") # читаем пенсы из консоли
        $exitflag = $true # если выше строкой возникло исключение, то эта строка выполнена  не будет - будет переход ранее выполнен в блок catch
    }
    catch # блок кетч для этого класса исключений InvalidCastFromStringToInteger
    {
        # внутри блока кетч нужно описать что делать, если возникла такая ошибка?
            write-host "значение должно быть числовым"
            $exitflag = $false
    }
}until($exitflag)

[double]$per=(20*12)/100 #считает соотношение стоимости фунта между новой и старой системой исчисления
[double]$sum = (($shilling*12+$pens)/$per)/100 #перевдит шиллинги в пенсы и считает общее количество, переводя в десятичный тип данных
$sum2 = $a+($funt+$sum) #складывает фунты с пенсами и записывает в новом формате исчисления 
Write-Host $sum2 

}


money # а что будет если пользователь ошибется и введет букву?
    # возникнет исключение, с кодом 
    # Cannot convert value "афываg" to type "System.Int32". Error: "Input string was not in a correct format."



######################
# пример использования валидации внутри функции: 
# пишутся специальные параметры аргумента, чтобы валидировать его значение на входе в функцию

### https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters?view=powershell-7.2 
function to-celsium {
    Param(
        [Parameter(Mandatory)] # аргумент обязательный, без него функци вызвана не будем
        #[AllowNull()]          # разрешает значение типа $null для этого аргумента
        #[AllowEmptyString()]   # разрешает аргументу быть пустой строкой
        [ValidatePattern("[0-9]+")]  # валидация аргумента по шаблону - только цифры один или более раз
        #[ValidateScript({$_.GetType().Name -notlike "string"})]
        #[ValidateSet("Low", "Average", "High")]
        #[ValidateNotNull()]
        [ValidateNotNullOrEmpty()]
        $FarenheitT
           )
    
    $F = ([Int32]::Parse($FarenheitT)*9/5+32)   # переводит значение по Цельсии в Фаренгейты
    write-host $F "`tпо Фаренгейту"
}




$x = [int] (Read-Host "Перевести значение по Фаренгейту в Цельсию - нажмите 1`n`rПеревести значение по Цельсию в Фаренгейты - нажмите 2`n`r") # определяется какое из ветвлений будет использовано для расчёта

switch ($x){

1 {to-celsium -FarenheitT (Read-host "Укажите значение по Цельсию")}  # здесь при вызове функции пройизойдет валидация
2 { # вторая часть в примере не участвует по валидации, но можно ее дописать в будущем:
    [int32]$Farengate=Read-host "Укажите значение по Фаренгейту"
    [int32]$C=($Farengate-32)*5/9 # переводит значение по Фаренгейту в Цельсии
    write-host $C "`tпо Цельсию"}
Default {}
    }