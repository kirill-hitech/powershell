# Урок 11: ПОТОКИ (STREAMs)

# (не путать с THREADs в процессах и мультизадачах ПО)

# поток (stream) - последовательность символов, к которым можно получить доступ.
# в дотнет - потоки представлены классами, основывающимися на классе System.IO.Stream

# зачем нужны потоки?
# 1. Контроль ошибок потока: контролируется целостность данных; данные можно запросить заново, если они не дошли.
# 2. Контроль скорости приема потока: приложение не всегда может быть готово отдать или принять поток - данные на этот случай помещаются в буфер (массив в памяти) и отсылаются лишь когда приложение готово их отдать и принять.

# при создании в памяти процесса , ОС создает по умолчанию три потока для него: ввод, ввывод, и поток ошибок.


# проиллюстрируем работу потока примером:
# 1. Открываем ТСР сокет 
# 2. попробуем послать туда данные из другого приложения


Function Receive-TCPMessage {
    Param ( 
        [Parameter(Mandatory=$true, Position=0)]
        [ValidateNotNullOrEmpty()] 
        [int] $Port
    ) 
    Process {
        Try { 
            # создаем ендпоинт 
            $endpoint = new-object System.Net.IPEndPoint([ipaddress]::any,$port) 

            # используя енпоинт мы создаем новый объект класса ТСР прослушивателя
            $listener = new-object System.Net.Sockets.TcpListener $EndPoint

            # вызваем метод СТАРТ нашего ТСР прослушивателя. В этот момент он создатся и будет виден в списке открытых сокетов ОС:
            $listener.start() 
 

            # вызваем метод AcceptTcpClient прослушивателя, чтобы установить ТСР соединени с другой стороной когда она подключится:
            $data = $listener.AcceptTcpClient() 
        
            # далее идет работа с потоком данных:
            # вызываем метод получения потока и пишем поток в переменную Stream. также создаем буфер для данных
            $stream = $data.GetStream() 
            $bytes = New-Object System.Byte[] 1024



            # далее мы читаем данные из потока и выводим их в консоль
            while (($i = $stream.Read($bytes,0,$bytes.Length)) -ne 0){
                $EncodedText = New-Object System.Text.ASCIIEncoding
                $data = $EncodedText.GetString($bytes,0, $i)
                Write-Output $data
            }
         
            # Close TCP connection and stop listening
            $stream.close()
            $listener.stop()
        }
        Catch {
            "Receive Message failed with: `n" + $Error[0]
        }
    }
}

# вызываем функцию
$msg = Receive-TCPMessage -Port 29800

# cmd > telnet localhost 29800 и вводим какие-то данные в телнет приложение

# в результате введеные данные в телнет видны в нашей переменной $MSG в том же порядке, в котором они были переданы через поток по сети

############################
# в павершеле есть набор коммандетов для перенаправления выходного потока 
# Out-Default                       Cmdlet    Microsoft.PowerShell.Core Sends the output to the default formatter and to the default output cmdlet.                                                                                                                                             
# Out-Host                          Cmdlet    Microsoft.PowerShell.Core Sends output to the command line.                                                                                                                                                                                       
# Out-Null                          Cmdlet    Microsoft.PowerShell.Core Hides the output instead of sending it down the pipeline or displaying it.  

#  Out-Default всегда подставляется в конец любой нашей строки интерпретатором: он нужен чтобы выходные данные выводить в стандартный поток вывода приложения (в результате мы видим вывод в консоль)


#### пример работы с потоком вывода
"Hello world!" | Out-Default #  видим вывод в консоли
"Hello world!" | Out-host #  видим вывод в консоли

# Out-Null перенаправляет выходной поток в никуда
"Hello world!" | Out-null #  НЕ видим вывод в консоли
Get-Process    | Out-null #  НЕ видим вывод в консоли

#### пример работы с потоком ввода

# Read-Host коммандлет читает поток ввода в консоль:
$var = Read-Host

#### пример работы с потоком ошибок

# создадим файл приложения .\Урок11_приложение.ps1
# внутри которго коммандет выхода Exit 0;
# вызовем его:
.\Урок11_приложение.ps1

# после вызова видно, что в консоли ничего не отобразилось!
# это связано с тем, что поток ошибок (кода выхода скрипта в данном случае) не выводится в консоль по умолчанию

# проверим что поток ошибок существует параллельно с потоком вывода в консоль по умолчанию:
# атоматическая переменная $LASTEXITCODE - фиксирует внутри себя последнюю ошибку, пришедшую в поток ошибок по умолчанию
$LASTEXITCODE # = 0 тк в приложении к уроку был указан exit 0;

# меняем код выхода скрипта приложения к уроку на exit 1;
.\Урок11_приложение.ps1
$LASTEXITCODE 


######################
# в многофайловых программах вы можете вызвать множество скриптов и управлять ветвлениями через $LASTEXITCODE 
.\Урок11_приложение.ps1
if($LASTEXITCODE ){}
elseif ($LASTEXITCODE -eq 2){}



######################
# резюмируем:
# exit {code} - завершает скрипт и возвращает в поток вывода ошибок значение {code} вызывающей ее программы (на экране поток не отобразается)