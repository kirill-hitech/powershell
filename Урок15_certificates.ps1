$age = 60


$discount = if ( $age -ge 55 ) 
                {
                    0.13
                }
            else {
                    if ( $age -le 13 )
                        {
                            0.07
                        }
                    else
                        {
                            0.00
                        }
                  }

$discount = if ( $age -ge 55 )
{
    0.07
}
elseif ( $age -le 13 )
{
    0.07
}
else
{
    0.00
}
            


$x = $x + 1
$x++ 


switch ($x)
{
    'value1' {}
    {$_ -in 'A','B','C'} {}
    'value3' {}
    Default {}
}

$processes = Get-Process  # array
foreach($process in $processes){ # для каждого процесса в массиве вывести на экран его имя
$process.ProcessName # $process - при итерации представляет текущий элемент массива
}

# выше - делает тоже что и 
Get-Process | ForEach-Object {$_.ProcessName}

# в данном примере спец переменная $_ представляет из себя текущий элемент массива при каждой итерации

# как массив распределен в памяти?
<#
[Byte[]]$byte = 22,23,25
0x0  # начало массива
0x1  22
0x2  23
0x3  25
0x4  0
0x5  
0x6  
0x7  
0x8  
0x9  
0xa  
0xb  
0xc  
0xd  
0xe  
0xf  


[Int32[]]$int32 = 2621,2622,2636
0x0  # начало массива
0x1 - 0x4  2621
0x5 - 0x9  2622
0xa - 0xd  2636
0xe        0   
0x5  
0x6  
0x7  
0x8  
0x9  
0xa  
0xb  
0xc  
0xd  
0xe  
0xf  

#>


#######################################
# ОС виндоус не предоставляет утилит для полной работы с сертификаами.
# есть C:\Windows\System32\certutil.exe но не всегда ее для работы с ними достаточно

# мы будем рассматривать в нашем уроке опен-сорс утилиту openSSL.exe
# которая по умолчанию в юникс системах используется для работы с сертификатами.
<# сам сертификат из себя предсталяет набор ключей.
1. открытый (публичный) ключ
2. закрытый (приватный) ключ
    - шифрованный паролем
    - открытый

как это работает? есть такие мат функции, которые при обратном преобразовании возвращают не одно значение, а несколько N(несколько тысяч).
таким обрзом, данные, зашифрованные с помощью октрытого ключа, могут быть назад верно расшифрованы (из N возможных значений) лишь с помощью приватного ключа.

приватный и публичный ключ - это числа.

 какие основные действия мы можем делать openssl?
 1. создать сертификат
 2. выделить из сертификата публичный и приватный ключ(шифрованный или в чистом виде)
 3. упаковать ключи в pfx файл (содержащий публичный и приватный ключи, цепочку паблик сертификатов)




#>



# генерация сертификата средствами Powershell 7+
cd Cert:\CurrentUser\My>
New-SelfSignedCertificate -KeyUsage DigitalSignature -DnsName "na" -Subject "test" -Type CodeSigningCert


# подписываем файл
$cert = Get-ChildItem Cert:\CurrentUser\My\0BA804ECFC10B8629A3A53C267C37B2D7D24F0A7
Set-AuthenticodeSignature -FilePath "C:\Users\admin\Desktop\PS lessons\Powershell\урок1(типизация данных).ps1" -Certificate $cert -HashAlgorithm `
sha256 -TimestampServer "http://timestamp.digicert.com"


# пример получения МД5 хеша файла. он тоже иногда исопльзуется при проверке подллинности файлов, например
# в интернете публикуется файл и рядом его мд5 хеш, скачав файл и сравнив опубликованный мд5 хеш 
# пользователь может понять что файл оригинальный.
Get-FileHash "C:\Users\admin\Desktop\PS lessons\Powershell\урок1(типизация данных).ps1" -Algorithm MD5