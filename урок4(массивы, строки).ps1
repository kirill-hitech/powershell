
# Урок 4: Массивы и строки
# массив - такая конструкция в памяти вычислительного устр-ва, в которой элементы одного типа идут друг за другом.
# простой пример массива в дотнет фреймворк это System.Array

# порядок работы с массивавми,
# 1. объявление массива. на этом этапе выделяется память.
# 2. определение массива: на этом этапе в выделенную память пишутся значения
# 3. работа с данными (их чтение или запись)
# пример простого объявления массива типа System.int32: тип массива, в котором все члены индексируются с нуля до какого то значения
<# System.Array
indx|value
0   |знач1
1   |знач2
2   |знач3
3   |знач4
4   |знач5
5   |знач6
...и так далее
#>

# массивы могут быть одномерные или многомерные
# массивы могут быть ограничены по длине при объявлении (через конструкторы или new-object коммандлет)
    # конструктор - это функция, которая всегда вызывается при объявлении\создании какого-либо типа объекта

# пример массива ограниченного по длине:
$array1 = New-Object -typename 'int32[]' -value 2 # будет создан массив типа int32 длиною 1 (командлет не воспроизводится)
$array1 = (New-Object -typename 'Int32[]' 1) # эта строчка читается => "будет создан массив типа int32 длиною 1"
$array1[0] = 5 # значение запишется в массив, так как находится в его границах.
$array1[1] = 7 # значение не запишется, так как находит вне гнаниц массива (масив ограничен по длине).

# указывается тип, затем идет знак массива [] (знак одномерного безразмерного в данном случае; многомерные массивы имеют точки по количеству),
# затем идет имя переменной-массива
[System.int32[]]$array1

# пример объявления с определением безразмерного одномерного массива, можно использовать оператор определения массива @():
[System.int32[]]$array2 = 11,22,33,44,55 # сокращенный синтаксис, без оператора @()
[System.int32[]]$array2 = @() # пустой массив без значений
[System.int32[]]$array2 = $null # отсутствие массива по ссылке
$array2[0] # ОШИБКА - невозможно обратиться по индексу к пустому массиву
[System.int32[]]$array2 = @(11,22,33,44,55) # делает то же самое что и сокращенный синтаксис выше

# пример чтения по индексу - указываем индекс после имени в квадратных скобках:
$array2[3]  # выведет элемент на экран
$array2[3] = 66  # перезапишет значение по этому индексу

$array2.GetType() # массив значений Int32[] наследован от System.Array

# вот некоторые полезные свойства и методы System.Array, которые можно быстро использовать:

    # 1. узнать длину массива - сколько в нем значений или индексов (отсчет начинается с единицы хотя индексы с нуля):
    $array2.Count
    $array2.Length

    # 2. узнать размерность массива - равна 1 так как массив одномерный
    $array2.Rank

    # 3. метод конвертирует наш массив в тип System.String
    $array2.ToString()

    # пример двухразмерного массива - 
# объявление и вызов статического конструктора типа Int32[,] и указание длины обоих массивов
[System.Int32[,]]$rank2 = [Int32[,]]::New(3,2)

<# при этом в памяти будет конструкция похожая на таблицу, где позиция каждого элемента описывается двумя числами:
       первое измерение (по горизонтали)
     0|   1|   2|
0|знач|знач|знач|
1|знач|знач|знач|

#>

# смотрим ранг и длину массива:
$rank2.rank     # ранк равен 2 - двумерный массив
$rank2.Length   # длина массива 6 - тк в нем всего 6 значений (рана произведению длин каждого измерения)

# задаем значения для отлдельных элементов двумерного массива:
$rank2[0,0] = 3
$rank2[0,1] = 3
$rank2[1,0] = 2
$rank2[1,1] = 3
$rank2[2,0] = 23
$rank2[2,1] = 23

# выводим значение элемента в позиции 1,1 на экран:
$rank2[1,1]

################

# массив может быть создан и для типа System.Char (числовой восьмибитный тип) который мы рассматривали на первом уроке
# например
[System.Char[]]$chars = 'a','b','c','d'  # помним, что символьные константы у нас пишутся внутри апострофов 'символ'

# в программировании со строками приходится работать много, поэтому
# чтобы не использовать массивы типа System.Char каждый раз,
# был создан специальный тип - строка, System.String (ссылочный встроенный типа)
# и это сильно упростило работу со строками:

# ЗАДАЧА:вывести на экран каждый элемент массива типа System.Char? например используя цикл for:
[System.Char[]]$chars = 'a','b','c','d' # объявляем массив и определяем значения

for($i = 0;$i -lt $chars.Length; $i++){ # выводим на экран
Write-Host $chars[$i]} # [$i] это индекс. $chars[$i] = $chars[0] -> $chars[1]... Выводится на экран значение каждого индекса исходя из условий в цикле for   

# ЗАДАЧА:вывести на экран каждый элемент массива типа System.String? 
[System.String]$str = "abcd" # помним, что строковые константы у нас пишутся внутри двойных апострофов "cтрока",
write-host $str # задача выполнена! - это намного проще чем работать c System.Char массивами

# вот некоторые полезные свойства и методы типа System.String
$str = "Hello world!"
    # 1. узнать длину строки
    $str.Length
    
    # 2. разделить строку, вернув массив из строк по какому-либо символу
    $str.Split(' ') # результат вернет нам массив из строк System.String[]

    # 3. позволяет вырезать из строки участок по шаблону
    $str.Trim("Hell")

    # 4. методы конвертации других типов к строке
    [System.int32]$a = 32; $a.GetType();$a.tostring().GetType()

    # 5. БОНУС: конвертация из строки в другие типы
    [System.String]$b = "32"; $b.GetType(); [System.int32]$c = [System.int32]::Parse($b); $c;$c.GetType()
    $d = [int32]::Parse("32") # тоже самое - используем строковую константу типа System.String

    # 6. проверить, есть ли строка в строке
    $str.Contains("Hello") # true

    # 7. объединить две строки в одну - статический метод Concat типа System.String
    [String]::Concat("Hello", " world!")
    
    # 8. заменить символ в строке на указанный
    $str.Replace('!','?')

# можно создавать массивы типа System.String 
[String[]]$strings = "string1","strinаsadfsadfasdfasdfasdfasdfg2"

# при этом выделение памяти происходит по другому принципу для ссылочных типов,
# пишутся ссылки вместо значений это дает нам возможность хранить в массиве
# элементы разной длины (что нельзя делать для числовых типов)
# также их сортировку это облегчает - нужно лишь менять ссылки местами а перезаписывать в памяти значения
<#
indx|value
0   |ссылка на знач
1   |ссылка на знач
2   |ссылка на знач
3   |ссылка на знач
4   |ссылка на знач
5   |ссылка на знач
...
посл| 0

...и так далее. Концом массива в данном случаае будет значение ноль в памяти
#>


###### ВАЖНО: не все символы, которые находятся в строке видны на экране

# пример 1:
# не виден символ переноса на новую строку и символ возврата каретки на лево
$str =  "hello 
world!"

$str.Length # в строке символов 14 !! при этом в первом слове букв 5, последнем 5, также есть пробел и воскл знак, итого 12

# какие символы содержатся внутри этого массива?
# рассмотрим как они располагаются друг за другом в памяти:
<#
0 |h
1 |e
2 |l
3 |l
4 |o
5 |  # тут пробел (он виден)
6 |  # тут символ переноса на новую строку (он не виден)
7 |  # тут символ возврата каретки (он не виден)
8 |w
9 |o
10|r
11|l
12|d
13|!
#>

# эти невидимые символы называются escape sequences,
# или управляющие последовательности. они не видны на экране но являются важно и неотъемлимой частью текста.


# управляющие последовательности можно вставлять в строки указывая апостроф (слева сверху на клавиатуре) и их код:
"Hello `n`rworld!".Length  # здесь в строку вставлены управляющие последовательности вручную -
    # `n - new line (начать новую строку)
    # `r - carriage return (перевести каретку влево до конца)

# еще один пример управляющих последовательностей в строках - символ табуляции cдвигает вправо следующее слово на следюудий 5й символ от начала строки
# это удобно использовать чтобы форматировать таблицы на экране

"12345`tworld!"
"12345678901234567890"

# каждая управляющая последовательность имеет числовое значение и может быть записана в System.Char тип


######
# есть спец коммандлеты для работы с массивами:
# Format-Table - приводит массив к таблице
# Sort-object  - сортирует массив по значению
# select-object - выбирает значения из массива

### слайсы массива (срезы)

### хештаблицы
################################################################

# есть массив, элементы в нем идут не сортированные
$array = (3,2,1,2,5,6,7,78,8,9,90,0,323)

################
# index # value#

# пример вызова пайплайна с присвоением результата
$array2 = $array | Sort-object -Descending -Unique
#-Descending меняет порядок сортировки - от большего к меньошему
#-Unique выбирает только уникальные значения из элементов массива

$array3 = Get-Process

$HT2 = @{

“key1” = $array3[3]

“key2” = $array3[15]

}

$ht2["key1"]

$array3 | Format-Table -Property Handles, ProcessName, @{Label=”Last access”;Expression={[DateTime]::Now}}
