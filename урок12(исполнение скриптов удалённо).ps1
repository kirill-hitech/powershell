# Урок 12
# исполнение скриптов удаленно, методы аутентификации, порты ТСР.
#  доп инфо:
    # аутентификация (authentification) - проверка пользователя, на предмет того, что он тот, за кого себя выдает. реалзиуется через пару логин-пароль, или сертификат.
    # авторизация    (authorization)    - проверка дейстия пользователя, на предмет того, что у него есть права выполнения. реализуется через АСL.

### что нужно для удаленной работы через remote-pssession?
# 1. Сконфигурированная служба WinRM на удаленном хосте.
    # сам по себе павершелл не имеет службы, которая бы могла прослушивать ТСР порт и принимать комманды.
    # роль такая возложена уже на готовую службу Windows Remote Management (WinRM) service
        # нужно учесть:
        # 1. служба работает, имеет тип старта automatic. Можно конфигурировать через GPO.
        # 2. служба сконфигурирована. по умолчанию конфигурация службы отсутствуют. Можно конфигурировать через GPO.
            # существуют скрипты конфигурации этой службы, они представлены файлами:
                # C:\Windows\System32\winrm.cmd
                # C:\Windows\System32\winrm.vbs 
            # ими можно пользоваться следующим образом из коммандной строки чтобы:
            #  - winrm qc                  сконфигурировать службу с параметрами поумолчанию
            #  - winrm get winrm/config  посмотреть текущую конфигурацию

            # какие базовые параметры служы у нее есть?
            # - два ТСР порта для прослушивания (один для шифрованного трафика 5985, второй для не шифрованого 5986)
            # - параметры аутентификации на порте: какой тип аутентификации используется
            # - ipv4 & ipv6 фильтры. они нужны, чтобы ограничить работу ТСР сокета, который будет слушать трафик.

 # 2. Доступ на транспортном уровне. Это значит что фаеролы не должны блокировать трафик ТСР по указанным портам.
 # 3. Учетные данные или сертификат для подключения.
      # winrm service поддерживат следующие методы аутенфикации. рассмотрим их быстро.
            # Negotiate - это не тип а утентификации. это указание согласовать аутентификацию между клиентом и сервером на их выбор.
                            # как это работает: клиент перед аутентификацие высылает свой список возможных споcбов, разрешенных для него^
                            # сервер ему высылает обратно свои способы, разрешенные для него,
                            # клиент сравнивает свой и серверный списки способов аутентификации, выбирает первый совпавший.

            
            
            # Basic -       Например, локальная запись на сервере, клиент знает логин и пароль и сервер знает логин и пароль. 
                            # Клиент берет логин и пароль, хеширует их (Fx(логин+пароль)=хеш), отправляет на сервер хеш для сверки. 
                            # сервер принимает этот хеш, делает ту же функцию для хранящихся на нем логине и пароле, и сравнивает хеши.

                            # что нужно иметь ввиду? если мы не используем SSL соединение, то передаваемый хеш может быть перехван злоумышленниками и использован, - он всегда постоянный

            
            # Digest       - это расширенный (более безопасный чем basic) метод аутентификации. Пароль также передается по сети к серверу, просто доплнительно шифруется.
                             # https://ru.wikipedia.org/wiki/%D0%94%D0%B0%D0%B9%D0%B4%D0%B6%D0%B5%D1%81%D1%82-%D0%B0%D1%83%D1%82%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F
                             # он является компромисом между небезопасным basic и сложным в реализации и требующим инфраструктуры kerberos. 

            # Certificate  - клиент должен иметь сертификат(и приватный ключ этого сертификата) и предъявить его(публичный) при подключении к серверу. Сервер получив публичную часть сертификата клиента
                            # проверяет его на соответсвие требованиям: доверенный ли клиент для сервера, нет ли его в списках отзыва СА, 
                            # попадает ли он под фильтры разршенных клиентов для аутентификации (например фильтр по полю шаблона).
                            # Если все ок - происходит мапинг(заранее определенный) сертификата с пользователем сервера, клиенту разрешается доступ от имени этого пользователя сервера.

            # Kerberos     - сервер не знает о логине и пароле. Клиент знает о логине и пароле. Есть третья сторона, которая знает о логине и пароле (Tiket Granting Service или TGS).
                            # клиент запрашивает у ТGS специальный тикет (Ticket Granting Ticket), не отсылая свой пароль. 
                            # TGS отсылает клиенту TGT зашифрованный его собственным паролем.
                            # клиент, получив шифрованный TGT и зная свой собственный пароль может его расшифровать [...сокращение...]
                            # клиент, имея TGT далее у TGS может запрашивать специальные керберос тикеты для аутентификации со службами и вставлять их в прикладные протоколы.

                            # сервер и TGS делают то же самое, получается:
                            # на прикладном уровне, в протоколе подключения обе стороны предъявляют друг другу керберос тикеты, которые после этого перекрестно сверяют TGS.[...сокращение...]

                            # что нужно иметь ввиду? метод аутентификации надежный, тк не проиходит пересылка пароля по сети никогда. но сложен в реализации тк требует ADDS.

                            
            # CredSSP       - это не метод аутентификации по своей сути. это использование специального модуля (библиотеки) виндоус для аутентификации третьесторонними приложениями.
                            # внутри может использовать разные протоколы аутентификации: NTLM или Kerberos5.

                            # важно отметить, что NLTM аутентификация уязвима к краже ntlm-хешей паролей, которые передаются по сети.
    

    ##############################
# пример соединения с хостом и исполнения на нем скриптблока

# 1. нужно создать специальный класс .net который будет содержать наши креденшиалс (учетные даныне)
 $password = ConvertTo-SecureString 'C7rfwa7' -AsPlainText -Force
 $credential = New-Object System.Management.Automation.PSCredential ('Administrator', $password)


# 2. создать новую удаленну powershell session с использованием определенной конфигурации
# https://docs.microsoft.com/ru-ru/powershell/module/microsoft.powershell.core/about/about_session_configurations?view=powershell-7.2

$pssession = New-PSSession -Credential $credential -ComputerName 172.16.241.16 -ConfigurationName "PowerShell.7.2.1"



# 3. далее мы можем в эту сессию отсылать скрипт блоки и получать их результат назад.
# чтобы послать локальную переменну в скриптблок, нужно использовать ключевое слово using:
# https://docs.microsoft.com/ru-ru/powershell/module/microsoft.powershell.core/about/about_remote_variables?view=powershell-7.2
# создадим локальную переменную
$var = $env:COMPUTERNAME


# 1 - скриптблок. это один из примеров работы с удаленной павершелл сессией 
# скрипт блок исполняется на удалённом компьютере
Invoke-Command -Session $pssession -scriptblock {

# пример использования передачи переменной в скриптблок
$using:var

$env:COMPUTERNAME

$host
(Get-PSSessionConfiguration).PSVersion

## давайте запустим процесс от другого пользователя

# и запускаем от имени его процесс
Start-Process -FilePath "C:\windows\system32\notepad.exe"
}


# 2 - скриптблок как задание. это тоже важный пример удаленной работы с павершелл сессией

Invoke-Command -Session $pssession -scriptblock {<#somejob#>} -AsJob 




Start-Process -FilePath "C:\Windows\System32\cmd.exe" -Credential $credential

 # using namespace System.Diagnostics
       
        if(-not ([EventLog]::SourceExists("2MySource2")))
        {
             
            [EventLog]::CreateEventSource("2MySource2", "Applicat");
            
        }

        # Create an EventLog instance and assign its source.
        [EventLog]$myLog = New-Object -TypeName System.Diagnostics.EventLog -ArgumentList "";
        $myLog.Source = "2MySource2";
        

        # Write an informational entry to the event log.
        $res = $myLog.WriteEntry("Writing to event log.");

        # 123asdfFF__
        # WIN-1TTV1JBPAQN\pwsh

# get-psssessionconfiguration выводит на экран доступные версии (конфигурации) павершелл


# используя созданную PSsession мы можем копировать через нее файлы

# например такой вызов можно сделать локально, чтобы скопировать файл на удаленный хост
Copy-Item -Path "C:\Users\admin\Downloads\ADMTV32MigGuide.zip" -Destination "c:\temp\" -ToSession $pssession 

# а так можно копировать в обратном направлении
Copy-Item -Path "C:\temp\ADMTV32MigGuide.zip" -Destination "c:\temp\" -FromSession $pssession 